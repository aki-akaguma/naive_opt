# Design of the `naive_opt` Library

## 1. Introduction

This document outlines the design of the `naive_opt` library. The design is guided by the requirements specified in `specs/0.requirements.md` and the acceptance criteria in `specs/1.acceptance-criteria.md`. The primary goal is to create a performant, naive string and byte slice search library with a flexible and idiomatic Rust API.

## 2. High-Level Architecture

The library is structured in four main layers:

1.  **Public API Layer**: This is the user-facing layer, providing traits (`Search`, `SearchBytes`) and standalone functions for ease of use. It defines *what* the user can do.
2.  **Dispatch Layer**: This internal layer contains the core search logic that dynamically chooses the most appropriate search algorithm based on the input.
3.  **Algorithm Implementation Layer**: This layer contains the concrete search algorithm implementations (`mc_1st` and `mc_last`).
4.  **Dependency Layer**: This layer consists of external crates, primarily `memx`, used for low-level, high-performance memory operations.

## 3. Detailed Design

### 3.1. Public API: Traits and Functions

The primary interface is built around two traits:
- `Search`: Implemented for `&str` and `String`. It provides the main set of search methods for string data.
- `SearchBytes`: Implemented for `&[u8]`, `&str`, and `String`. It provides search methods for byte slice data.

These traits allow for idiomatic use, e.g., `haystack.search(needle)`. To support a wider range of needle types (`&str`, `String`, `char`), the traits are generic over a `SearchIn` (or `SearchInBytes`) trait, which handles the specific implementation for each needle type.

For users who prefer a functional approach, standalone functions like `string_search` and `string_rsearch` are provided, which wrap the core trait implementations.

*This design addresses: AC4, AC5, AC6, AC9.*

### 3.2. Dispatch: The Optimization Strategy

The core of the library's performance optimization is the dispatch function `naive_opt_mc_bytes` (and its reverse and case-insensitive variants). This function does not implement one single algorithm; instead, it acts as a smart dispatcher.

When a search is initiated, this function inspects the first and last bytes of the `needle`:
1.  It looks up the statistical frequency of these bytes in a pre-computed table, `_ASCII_STOCHAS`.
2.  It compares the frequency (weight) of the first byte against the last byte.
3.  If the first byte is less common or equally common, it dispatches the search to the `mc_1st` module. Otherwise, it dispatches to the `mc_last` module.

This stochastic choice aims to use the byte that is least likely to occur in the haystack as the primary filter, reducing the number of full comparisons needed.

This strategy can be overridden at compile time using the `only_mc_1st` and `only_mc_last` feature flags.

### 3.3. Algorithms: `mc_1st` and `mc_last`

- **`mc_1st.rs`**: Implements the search by first looking for the *first byte* of the needle in the haystack using `memx::iter::memchr_iter`. Once a candidate position is found, it performs a full byte-for-byte comparison of the needle.
- **`mc_last.rs`**: Implements the search by looking for the *last byte* of the needle. This is often more efficient as it allows for larger jumps in the haystack.

Both modules provide forward, reverse, and case-insensitive versions of their respective algorithms.

*This design addresses: AC1, AC2.*

### 3.4. Iterator Design

To find all occurrences, the library uses dedicated iterator structs (e.g., `SearchIndices`, `RevSearchIndices`).
- Each struct holds the search state: a reference to the haystack, the needle, and the current position (`curr_idx` for forward, `curr_ed` for reverse).
- They implement the standard `Iterator` trait.
- The `next()` method on the iterator calls the appropriate core search function on the remaining portion of the haystack. It then updates its internal state to ensure the next search starts after the current match, preventing overlapping results.

*This design addresses: AC7, AC8.*

### 3.5. Case-Insensitive Search

Case-insensitivity is handled by `_iac` suffixed functions (e.g., `naive_opt_mc_bytes_iac`).
- Instead of searching for a single byte, they search for both the uppercase and lowercase variants of the target byte (e.g., `a` and `A`).
- This is achieved using `memx::iter::memchr_dbl_iter`, which can efficiently search for two different bytes simultaneously.
- Once a potential match is found, the full comparison is done using `eq_ignore_ascii_case`.

*This design addresses: AC10.*

## 4. Requirements Traceability

- **AC1, AC2 (First/Last Match):** Implemented by `naive_opt_mc_bytes` and `naive_opt_mc_rev_bytes`, which are dispatched from the public API.
- **AC3 (Existence Check):** Implemented by the public `includes` method, which calls the appropriate search function and checks if the result `is_some()`.
- **AC4, AC5 (Data Types):** Handled by the `Search` and `SearchBytes` trait implementations for `&str`, `String`, and `&[u8]`.
- **AC6 (Needle Types):** Handled by the generic design of the `SearchIn` and `SearchInBytes` traits.
- **AC7, AC8 (Iterators):** Implemented by the `SearchIndices` and `RevSearchIndices` structs (and their variants).
- **AC9 (Trait API):** The core design is built on the `Search` and `SearchBytes` traits.
- **AC10 (Case-Insensitive):** Implemented by the `_iac` functions using double-byte searching and case-insensitive equality checks.
