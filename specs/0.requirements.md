# Requirements for `naive_opt`

## 1. Overview

`naive_opt` is a Rust library designed to provide a highly optimized implementation of naive (or "brute-force") search for sub-slices within larger slices. It is intended as a potential replacement for some of the standard library's string searching functions, offering enhanced performance and additional features.

The core optimization strategy involves a stochastic choice between two approaches:
1.  **First-Byte Match (`mc_1st`):** Quickly scan the haystack for the first byte of the needle and then verify the full match.
2.  **Last-Byte Match (`mc_last`):** Quickly scan the haystack for the last byte of the needle and then verify the full match.

The library selects the strategy based on a pre-computed frequency analysis of ASCII characters, but this can be overridden at compile time.

## 2. Functional Requirements

### 2.1. Core Search Operations
- The library MUST provide functionality to find the byte index of the **first** occurrence of a `needle` within a `haystack`.
- The library MUST provide functionality to find the byte index of the **last** occurrence of a `needle` within a `haystack`.
- The library MUST provide a method to simply check for the existence of a `needle` in a `haystack` (e.g., `includes` or `contains`).

### 2.2. Supported Data Types
- All search operations MUST be supported for UTF-8 string slices (`&str`) and owned strings (`String`).
- All search operations MUST be supported for byte slices (`&[u8]`).

### 2.3. API Design
- The library MUST provide a `Search` trait to be implemented for string types, allowing for an idiomatic, method-based invocation (e.g., `haystack.search(needle)`).
- The library MUST provide a `SearchBytes` trait to be implemented for byte slice types.
- The library MUST provide standalone functions for all core search operations (e.g., `string_search(...)`).
- The API should be generic to accept various needle types (`&str`, `String`, `char`) where applicable.

### 2.4. Iterators for Multiple Matches
- The library MUST provide an iterator that yields all non-overlapping matches of a `needle` in a `haystack` from start to end (`search_indices`).
- The library MUST provide an iterator that yields all non-overlapping matches of a `needle` in a `haystack` from end to start (`rsearch_indices`).
- Both iterators MUST return the starting byte index and the matched slice for each match.

### 2.5. Case-Insensitive Search
- All search functionalities (first/last occurrence, includes, iterators) MUST have a corresponding version that performs an **ASCII case-insensitive** comparison.

## 3. Non-Functional Requirements

### 3.1. Performance
- The implementation MUST be optimized for speed, leveraging fast byte-searching (`memchr`) provided by dependencies like `memx`.
- The choice of search strategy (first-byte vs. last-byte) SHOULD be determined automatically based on ASCII character frequency to maximize performance for common text.

### 3.2. Compatibility
- The library's functionality SHOULD be a drop-in replacement for the following `std::str` methods, with a clear mapping provided in the documentation:
    - `find()`
    - `rfind()`
    - `contains()`
    - `match_indices()`
    - `rmatch_indices()`
- The minimum supported Rust version MUST be clearly stated (e.g., 1.56.1).

### 3.3. Configuration
- The library MUST allow users to force a specific search strategy at compile time via feature flags (`only_mc_1st`, `only_mc_last`).

### 3.4. Dependencies
- The library will depend on the `memx` crate for optimized memory operations. This dependency should be documented.
